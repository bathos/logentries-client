
// IMPORTS /////////////////////////////////////////////////////////////////////

import _      from 'lodash';
import jsonSS from 'json-stringify-safe';

// PATTERNS ////////////////////////////////////////////////////////////////////

const stackDelim = /\n\s*/g;

// UTIL ////////////////////////////////////////////////////////////////////////

const pass = (key, val) => val;

const isNewIterable = val => {
	return (
		(Map && val instanceof Map) ||
		(Set && val instanceof Set) ||
		(WeakMap && val instanceof WeakMap) ||
		(WeakSet && val instanceof WeakSet)
	);

	// Though it might be a nice touch to spread generators too, it’d be way too
	// presumptuous (could have side effects, could be infinite). As it is,
	// functions and generators both just disappear into the night, though the
	// user can change this with a custom replacer.
}

// BUILD SERIALIZER ////////////////////////////////////////////////////////////

export const build = ({ flatten, flattenArrays, replacer=pass, withStack }) => {
	// We augment the default JSON.stringify serialization behavior with
	// handling for a number of values that otherwise return nonsense values or
	// nothing at all. In addition to numeric outliers, a number of other basic
	// JS objects (post-ES6 especially) aren’t in the JSON spec, presumably
	// because it would have been too obvious that we were tricking everyone
	// else into making our lives easier. This augmented behavior is useful in a
	// JS environment since we’re not apt to think ‘I am going to log JSON!’; we
	// just want to dump objects in the log hole.

	// json-stringify-safe takes care of circular references.

	// If the user supplied a custom replacer, it is applied first.

	const serialize = _.partial(jsonSS, _, _.flow(replacer, val => {
		// Trouble primitives
		if (_.isNaN(val))              return 'NaN';
		if (val === Infinity)          return 'Infinity';
		if (val === -Infinity)         return '-Infinity';
		if (1 / val === -Infinity)     return '-0';
		if (typeof val == 'symbol')    return val.toString();

		// Trouble objects
		if (_.isError(val))            return errReplacer(val, withStack);
		if (_.isArguments(val))        return _.toArray(val);
		if (_.isRegExp(val))           return val.toString();
		if (isNewIterable(val))        return [ ...val ];

		// - Error, regexp, maps and sets would have been `{}`
		// - Arguments would have been `{"0": "arg1", "1": "arg2" }`
		// - NaN and +/-Infinity would have been `null` (wtf?)
		// - -0 would have been 0 (yes I’m being overly thorough)
		// - Symbols would have been undefined

		// Note: numeric literals in base-whatever are just standard decimal
		// integers internally, so 0b1 will be "1" -- the original notation
		// can’t be preserved. JSON does preserve exponent suffixes though.

		return val;
	}));

	return flatten ? flat(serialize, flattenArrays) : serialize;
};

const errReplacer = (val, withStack) => {

	// Errors do not serialize nicely with JSON.stringify because none of the
	// properties of interest are ‘own’ properties.

	const err = { name: val.name || 'Error', message: val.message };

	// Though custom errors could have some own properties:

	for (const prop in val) err[prop] = val[prop];

	// For the stack, we convert to an array for the sake of readability.

	if (withStack) err.stack = val.stack && val.stack.split(stackDelim);

	return err;
}

const flat = (serialize, arraysToo) => {
	return (obj) => {
		obj = JSON.parse(serialize(obj));

		if (!_.isObject(obj)) return obj;

		const flatObj = _.reduce(obj, function _flat(target, val, key) {

			const keyContext = this.slice();

			keyContext.push(key);

			key = keyContext.join('.');

			if (!_.isObject(val))
				target[key] = val;

			else if (!arraysToo && _.isArray(val))
				target[key] = val.map(val => {
					if (!_.isObject(val)) return val;

					return _.reduce(val, _flat, {}, []);
				});

			else
				_.reduce(val, _flat, target, keyContext);

			return target;
		}, {}, []);

		return jsonSS(flatObj);
	}
};
